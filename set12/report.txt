Description of machine used for benchmarking
--------------------------------------------

Manufacturer, model, and year manufactured: Apple Inc., MacBook Pro (Retina, 13-inch), Early 2015

Processor: 2.7 GHz Intel Core i5

Clock speed: 2.7 GHz

Size of main memory: 8 GB 1867 MHz DDR3


Question 1
----------

For each of the following, report the elapsed (not cpu) time,
in seconds, on your benchmark machine.  If your interpreter
doesn't work, or returns an incorrect result, leave those
timings blank.

    Benchmark:    java Programs fib.ps11 35 1
    Timing:       8.60s

    Benchmark:    larceny --r7rs --program fib.ps11.scm -- 35 100
    Timing:       14.51s

    Benchmark:    java Fib 35 100
    Timing:       0.04s

For each of the following, write down the largest power of 10
you can substitute for N without getting a stack overflow:

    Benchmark:    java Programs sumsq.ps11 N 1
    Largest N:    3

    Benchmark:    java Sumsq N 1
    Largest N:    4

    Benchmark:    java -Xss100M Programs sumsq.ps11 N 1
    Largest N:    5

    Benchmark:    java -Xss100M Sumsq N 1
    Largest N:    6

For each of the following, report the elapsed (not cpu) time,
in seconds, on your benchmark machine.  If a benchmark doesn't
work, or encounters a stack overflow, or returns a wrong answer,
leave those timings blank.

    Benchmark:    java -Xss100M Programs sumsq.ps11 10000 100000
    Timing:       350.62s

    Benchmark:    larceny --r7rs --program sumsq.ps11.scm -- 10000 100000
    Timing:       4.26s

    Benchmark:    java -Xss100M Sumsq 10000 100000
    Timing:       1.84s

    Benchmark:    java Sumsq2 10000 100000
    Timing:       1.97s


Question 2
----------

For each of the following, report the elapsed (not cpu) time,
in seconds, as shown in the output on your benchmark machine.

    Benchmark:    gcc gcbench.c; ./a.out
    Timing:       2.235s

    Benchmark:    java GCBench
    Timing:       0.276s

    Benchmark:    java -Xmx64M GCBench
    Timing:       0.282s

    Benchmark:    larceny --r7rs --program gcbenchJ.scm
    Timing:       1.0s

For each of the following, report the elapsed (not cpu) time,
in seconds, as shown in the output on your benchmark machine.

    Benchmark:    gcc permNKL.c; ./a.out
    Timing:       44.096

    Benchmark:    java PermNKL
    Timing:       20.798

    Benchmark:    java -Xmx500M PermNKL
    Timing:       45.951

    Benchmark:    larceny --r7rs --program permJ.scm
    Timing:       26.0

    Benchmark:    larceny --stopcopy --load 4 --r7rs --program permJ.scm
    Timing:       14.0

To obtain a succinct description of the options used above, type

    java -X
    larceny --wizard

Suppose someone asks you whether explicit deallocation, as in C,
is faster than garbage collection.  After running the benchmarks
above, how would you answer that question?

