Description of machine used for benchmarking
--------------------------------------------

Manufacturer, model, and year manufactured: Apple Inc., MacBook Pro (Retina, 13-inch), Early 2015

Processor: 2.7 GHz Intel Core i5

Clock speed: 2.7 GHz

Size of main memory: 8 GB 1867 MHz DDR3


Question 1
----------

For each of the following, report the elapsed (not cpu) time,
in seconds, on your benchmark machine.  If your interpreter
doesn't work, or returns an incorrect result, leave those
timings blank.

    Benchmark:    java Programs fib.ps11 35 1
    Timing:       6.51 seconds

    Benchmark:    larceny --r7rs --program fib.ps11.scm -- 35 100
    Timing:       14.51 seconds

    Benchmark:    java Fib 35 100
    Timing:       0.04 seconds

For each of the following, write down the largest power of 10
you can substitute for N without getting a stack overflow:

    Benchmark:    java Programs sumsq.ps11 N 1
    Largest N:    3

    Benchmark:    java Sumsq N 1
    Largest N:    4

    Benchmark:    java -Xss100M Programs sumsq.ps11 N 1
    Largest N:    5

    Benchmark:    java -Xss100M Sumsq N 1
    Largest N:    6

For each of the following, report the elapsed (not cpu) time,
in seconds, on your benchmark machine.  If a benchmark doesn't
work, or encounters a stack overflow, or returns a wrong answer,
leave those timings blank.

    Benchmark:    java -Xss100M Programs sumsq.ps11 10000 100000
    Timing:       350.62 seconds

    Benchmark:    larceny --r7rs --program sumsq.ps11.scm -- 10000 100000
    Timing:       4.26 seconds

    Benchmark:    java -Xss100M Sumsq 10000 100000
    Timing:       1.84 seconds

    Benchmark:    java Sumsq2 10000 100000
    Timing:       0.97 seconds


Question 2
----------

For each of the following, report the elapsed (not cpu) time,
in seconds, as shown in the output on your benchmark machine.

    Benchmark:    gcc gcbench.c; ./a.out
    Timing:       2.235 seconds

    Benchmark:    java GCBench
    Timing:       0.276 seconds

    Benchmark:    java -Xmx64M GCBench
    Timing:       0.282 seconds

    Benchmark:    larceny --r7rs --program gcbenchJ.scm
    Timing:       1.0 second

For each of the following, report the elapsed (not cpu) time,
in seconds, as shown in the output on your benchmark machine.

    Benchmark:    gcc permNKL.c; ./a.out
    Timing:       44.096 seconds

    Benchmark:    java PermNKL
    Timing:       20.798 seconds

    Benchmark:    java -Xmx500M PermNKL
    Timing:       45.951 seconds

    Benchmark:    larceny --r7rs --program permJ.scm
    Timing:       26.0 seconds

    Benchmark:    larceny --stopcopy --load 4 --r7rs --program permJ.scm
    Timing:       14.0 seconds

To obtain a succinct description of the options used above, type

    java -X
    larceny --wizard

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Suppose someone asks you whether explicit deallocation, as in C,
is faster than garbage collection.  After running the benchmarks
above, how would you answer that question?


Short Answer:
------------
It is not possible to compare GC and explicit memory de-allocation.

Long Answer:
-----------
Garbage Collection, hereafter called GC, is a special case of explicit memory de-allocation.
Speed of execution of a program can not be attributed to only GC or explicit memory de-allocation
because it depends on multiple factors: programming language, processor architecture, type of input data and
algorithm used.

By looking at the result of running benchmarks we can make following inferences:
1) If the memory allocated is too small then frequent attempts at freeing memory will increase the total execution
   of the program.
2) Java does not have tail recursion, hence iterative code written in java gives better time performance as compared to
   recursive version.

Hence, we can say, running time of a program can not be attributed to type of memory management strategy used (GC vs
explicit).

Furthermore, in practice the choice between a language that has GC vs a language which needs explicit memory
management is not only dependant on running time, following points are also considered:
1) Does the language discourage need of manual memory management thereby avoiding memory leaks
2) Does the language provide tools for debugging memory leaks or similar problems
3) Does the application we are building need the maximum speed we can get at a risk of possible memory leaks
   or are we willing to sacrifice and have an application that has (slightly?) more running time but is stable.
4) What do developers prefer

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////